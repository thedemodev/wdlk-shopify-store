'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.downloadFromUrl = downloadFromUrl;
exports.unzip = unzip;
exports.writePackageJsonSync = writePackageJsonSync;
exports.startProcess = startProcess;
exports.hasDependency = hasDependency;
exports.move = move;
exports.isShopifyTheme = isShopifyTheme;
exports.isShopifyThemeWhitelistedDir = isShopifyThemeWhitelistedDir;

var _fs = require('fs');

var _path = require('path');

var _unzip = require('unzip2');

var _https = require('https');

var _crossSpawn = require('cross-spawn');

var _crossSpawn2 = _interopRequireDefault(_crossSpawn);

var _mv = require('mv');

var _mv2 = _interopRequireDefault(_mv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Download file from url and write to target.
 *
 * @param {string} source - The url to the file to download.
 * @param {string} target - The path to the file destination.
 *
 * @return {string} - The path to the file destination.
 */
function downloadFromUrl(source, target) {
  return new Promise(function (resolve, reject) {
    var themeZipFile = (0, _fs.createWriteStream)(target);

    themeZipFile.on('open', function () {
      (0, _https.get)(source, function (response) {
        response.pipe(themeZipFile);
      });
    });

    themeZipFile.on('error', function (err) {
      (0, _fs.unlinkSync)(target);
      reject(err);
    });

    themeZipFile.on('close', function () {
      resolve(target);
    });
  });
}

/**
 * Extract zip file to target and unlink zip file.
 *
 * @param {string} source - The path to the zip file.
 * @param {string} target - The path to the unzip destination.
 */
function unzip(source, target) {
  return new Promise(function (resolve, reject) {
    var zipFile = (0, _fs.createReadStream)(source);

    zipFile.on('error', function (err) {
      reject(err);
    });

    zipFile.on('close', function () {
      (0, _fs.unlinkSync)(source);
      resolve(target);
    });

    zipFile.pipe((0, _unzip.Extract)({
      path: target
    }));
  });
}

/**
 * Write minimal package.json to destination.
 *
 * @param {string} target - The path to the target package.json.
 * @param {string} name - The name of the theme.
 */
function writePackageJsonSync(target) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'theme';

  var pkg = {
    name: name,
    version: '0.0.1'
  };

  var data = JSON.stringify(pkg, null, 2);

  (0, _fs.writeFileSync)(target, data);
}

/**
 * Start a child process and stream output.
 *
 * @param {string} command - The command to run.
 * @param {string} args - List of string arguments.
 * @param {string} args - Options object
 *
 * See: https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
 */
function startProcess(command, args, options) {
  var defaultedOptions = options || {};
  defaultedOptions.stdio = defaultedOptions.stdio || 'inherit';

  return new Promise(function (resolve, reject) {
    var child = (0, _crossSpawn2.default)(command, args, defaultedOptions);

    child.on('error', function (err) {
      reject(err);
    });

    child.on('close', function (code) {
      resolve(code);
    });
  });
}

/**
 * Check for dependency name on package.json
 *
 * @param {string} dependencyName - The name of the dependency.
 * @param {object} pkg - The package.json object.
 */
function hasDependency(dependencyName, pkg) {
  var depKeys = ['dependencies', 'devDependencies'];
  var hasDependencies = false;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = depKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (key in pkg && dependencyName in pkg[key]) {
        hasDependencies = true;
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return hasDependencies;
}

/**
 * Moves file from one location to another
 *
 * @param {string} oldPath - The path to the file.
 * @param {string} newPath - The path to the new file.
 */
function move(oldPath, newPath) {
  return new Promise(function (resolve, reject) {
    (0, _mv2.default)(oldPath, newPath, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve();
    });
  });
}

/**
 * Tests if directory is a Shopify theme
 *
 * @param {string} directory - The path to the directory.
 */
function isShopifyTheme(directory) {
  var layoutTheme = (0, _path.join)(directory, (0, _path.normalize)('layout/theme.liquid'));
  return (0, _fs.existsSync)(layoutTheme);
}

/**
 * Tests if directory belongs to Shopify themes
 *
 * @param {string} directory - The path to the directory.
 */
function isShopifyThemeWhitelistedDir(directory) {
  var whitelist = ['assets', 'layout', 'config', 'locales', 'sections', 'snippets', 'templates'];
  return whitelist.indexOf(directory) > -1;
}